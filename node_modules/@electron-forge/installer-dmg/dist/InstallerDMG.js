"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _installerDarwin = _interopRequireDefault(require("@electron-forge/installer-darwin"));

var _crossSpawnPromise = require("@malept/cross-spawn-promise");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _hdiutil = require("./util/hdiutil");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class InstallerDMG extends _installerDarwin.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'dmg');
  }

  async install({
    filePath,
    installSpinner
  }) {
    const mounts = await (0, _hdiutil.getMountedImages)();
    let targetMount = mounts.find(mount => mount.imagePath === filePath);

    if (!targetMount) {
      targetMount = await (0, _hdiutil.mountImage)(filePath);
    }

    try {
      const volumePath = _path.default.resolve('/Volumes', targetMount.mountPath);

      const appName = (await _fsExtra.default.readdir(volumePath)).find(file => file.endsWith('.app'));

      if (!appName) {
        throw new Error('Failed to find .app file in DMG');
      }

      const appPath = _path.default.resolve(volumePath, appName);

      const targetApplicationPath = `/Applications/${_path.default.basename(appPath)}`;
      await this.moveApp(appPath, targetApplicationPath, installSpinner, true);
      await (0, _crossSpawnPromise.spawn)('open', ['-R', targetApplicationPath], {
        detached: true
      });
    } finally {
      await (0, _hdiutil.unmountImage)(targetMount);
    }
  }

}

exports.default = InstallerDMG;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9JbnN0YWxsZXJETUcudHMiXSwibmFtZXMiOlsiSW5zdGFsbGVyRE1HIiwiSW5zdGFsbGVyRGFyd2luIiwiaW5zdGFsbCIsImZpbGVQYXRoIiwiaW5zdGFsbFNwaW5uZXIiLCJtb3VudHMiLCJ0YXJnZXRNb3VudCIsImZpbmQiLCJtb3VudCIsImltYWdlUGF0aCIsInZvbHVtZVBhdGgiLCJwYXRoIiwicmVzb2x2ZSIsIm1vdW50UGF0aCIsImFwcE5hbWUiLCJmcyIsInJlYWRkaXIiLCJmaWxlIiwiZW5kc1dpdGgiLCJFcnJvciIsImFwcFBhdGgiLCJ0YXJnZXRBcHBsaWNhdGlvblBhdGgiLCJiYXNlbmFtZSIsIm1vdmVBcHAiLCJkZXRhY2hlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7OztBQUVlLE1BQU1BLFlBQU4sU0FBMkJDLHdCQUEzQixDQUEyQztBQUFBO0FBQUE7O0FBQUEsa0NBQ2pELEtBRGlEO0FBQUE7O0FBR3hELFFBQU1DLE9BQU4sQ0FBYztBQUNaQyxJQUFBQSxRQURZO0FBRVpDLElBQUFBO0FBRlksR0FBZCxFQUdxQjtBQUNuQixVQUFNQyxNQUFNLEdBQUcsTUFBTSxnQ0FBckI7QUFDQSxRQUFJQyxXQUFXLEdBQUdELE1BQU0sQ0FBQ0UsSUFBUCxDQUFhQyxLQUFELElBQVdBLEtBQUssQ0FBQ0MsU0FBTixLQUFvQk4sUUFBM0MsQ0FBbEI7O0FBRUEsUUFBSSxDQUFDRyxXQUFMLEVBQWtCO0FBQ2hCQSxNQUFBQSxXQUFXLEdBQUcsTUFBTSx5QkFBV0gsUUFBWCxDQUFwQjtBQUNEOztBQUVELFFBQUk7QUFDRixZQUFNTyxVQUFVLEdBQUdDLGNBQUtDLE9BQUwsQ0FBYSxVQUFiLEVBQXlCTixXQUFXLENBQUNPLFNBQXJDLENBQW5COztBQUNBLFlBQU1DLE9BQU8sR0FBRyxDQUFDLE1BQU1DLGlCQUFHQyxPQUFILENBQVdOLFVBQVgsQ0FBUCxFQUErQkgsSUFBL0IsQ0FBcUNVLElBQUQsSUFBVUEsSUFBSSxDQUFDQyxRQUFMLENBQWMsTUFBZCxDQUE5QyxDQUFoQjs7QUFDQSxVQUFJLENBQUNKLE9BQUwsRUFBYztBQUNaLGNBQU0sSUFBSUssS0FBSixDQUFVLGlDQUFWLENBQU47QUFDRDs7QUFDRCxZQUFNQyxPQUFPLEdBQUdULGNBQUtDLE9BQUwsQ0FBYUYsVUFBYixFQUF5QkksT0FBekIsQ0FBaEI7O0FBQ0EsWUFBTU8scUJBQXFCLEdBQUksaUJBQWdCVixjQUFLVyxRQUFMLENBQWNGLE9BQWQsQ0FBdUIsRUFBdEU7QUFFQSxZQUFNLEtBQUtHLE9BQUwsQ0FBYUgsT0FBYixFQUFzQkMscUJBQXRCLEVBQTZDakIsY0FBN0MsRUFBNkQsSUFBN0QsQ0FBTjtBQUVBLFlBQU0sOEJBQU0sTUFBTixFQUFjLENBQUMsSUFBRCxFQUFPaUIscUJBQVAsQ0FBZCxFQUE2QztBQUFFRyxRQUFBQSxRQUFRLEVBQUU7QUFBWixPQUE3QyxDQUFOO0FBQ0QsS0FaRCxTQVlVO0FBQ1IsWUFBTSwyQkFBYWxCLFdBQWIsQ0FBTjtBQUNEO0FBQ0Y7O0FBN0J1RCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBJbnN0YWxsZXJEYXJ3aW4sIHsgSW5zdGFsbGVyT3B0aW9ucyB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9pbnN0YWxsZXItZGFyd2luJztcblxuaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdAbWFsZXB0L2Nyb3NzLXNwYXduLXByb21pc2UnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBnZXRNb3VudGVkSW1hZ2VzLCBtb3VudEltYWdlLCB1bm1vdW50SW1hZ2UgfSBmcm9tICcuL3V0aWwvaGRpdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluc3RhbGxlckRNRyBleHRlbmRzIEluc3RhbGxlckRhcndpbiB7XG4gIG5hbWUgPSAnZG1nJztcblxuICBhc3luYyBpbnN0YWxsKHtcbiAgICBmaWxlUGF0aCxcbiAgICBpbnN0YWxsU3Bpbm5lcixcbiAgfTogSW5zdGFsbGVyT3B0aW9ucykge1xuICAgIGNvbnN0IG1vdW50cyA9IGF3YWl0IGdldE1vdW50ZWRJbWFnZXMoKTtcbiAgICBsZXQgdGFyZ2V0TW91bnQgPSBtb3VudHMuZmluZCgobW91bnQpID0+IG1vdW50LmltYWdlUGF0aCA9PT0gZmlsZVBhdGgpO1xuXG4gICAgaWYgKCF0YXJnZXRNb3VudCkge1xuICAgICAgdGFyZ2V0TW91bnQgPSBhd2FpdCBtb3VudEltYWdlKGZpbGVQYXRoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgdm9sdW1lUGF0aCA9IHBhdGgucmVzb2x2ZSgnL1ZvbHVtZXMnLCB0YXJnZXRNb3VudC5tb3VudFBhdGgpO1xuICAgICAgY29uc3QgYXBwTmFtZSA9IChhd2FpdCBmcy5yZWFkZGlyKHZvbHVtZVBhdGgpKS5maW5kKChmaWxlKSA9PiBmaWxlLmVuZHNXaXRoKCcuYXBwJykpO1xuICAgICAgaWYgKCFhcHBOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZpbmQgLmFwcCBmaWxlIGluIERNRycpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXBwUGF0aCA9IHBhdGgucmVzb2x2ZSh2b2x1bWVQYXRoLCBhcHBOYW1lKTtcbiAgICAgIGNvbnN0IHRhcmdldEFwcGxpY2F0aW9uUGF0aCA9IGAvQXBwbGljYXRpb25zLyR7cGF0aC5iYXNlbmFtZShhcHBQYXRoKX1gO1xuXG4gICAgICBhd2FpdCB0aGlzLm1vdmVBcHAoYXBwUGF0aCwgdGFyZ2V0QXBwbGljYXRpb25QYXRoLCBpbnN0YWxsU3Bpbm5lciwgdHJ1ZSk7XG5cbiAgICAgIGF3YWl0IHNwYXduKCdvcGVuJywgWyctUicsIHRhcmdldEFwcGxpY2F0aW9uUGF0aF0sIHsgZGV0YWNoZWQ6IHRydWUgfSBhcyBhbnkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCB1bm1vdW50SW1hZ2UodGFyZ2V0TW91bnQpO1xuICAgIH1cbiAgfVxufVxuIl19