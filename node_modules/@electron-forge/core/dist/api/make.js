"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

require("colors");

var _asyncOra = require("@electron-forge/async-ora");

var _get = require("@electron/get");

var _makerBase = _interopRequireDefault(require("@electron-forge/maker-base"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));

var _hook = require("../util/hook");

var _messages = require("../util/messages");

var _parseArchs = _interopRequireDefault(require("../util/parse-archs"));

var _readPackageJson = require("../util/read-package-json");

var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));

var _outDir = _interopRequireDefault(require("../util/out-dir"));

var _electronVersion = require("../util/electron-version");

var _requireSearch = _interopRequireDefault(require("../util/require-search"));

var _package = _interopRequireDefault(require("./package"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class MakerImpl extends _makerBase.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'impl');

    _defineProperty(this, "defaultPlatforms", []);
  }

}

function generateTargets(forgeConfig, overrideTargets) {
  if (overrideTargets) {
    return overrideTargets.map(target => {
      if (typeof target === 'string') {
        return forgeConfig.makers.find(maker => maker.name === target) || {
          name: target
        };
      }

      return target;
    });
  }

  return forgeConfig.makers;
}

var _default = async ({
  dir = process.cwd(),
  interactive = false,
  skipPackage = false,
  arch = (0, _get.getHostArch)(),
  platform = process.platform,
  overrideTargets,
  outDir
}) => {
  _asyncOra.asyncOra.interactive = interactive;
  let forgeConfig;
  await (0, _asyncOra.asyncOra)('Resolving Forge Config', async () => {
    const resolvedDir = await (0, _resolveDir.default)(dir);

    if (!resolvedDir) {
      throw new Error('Failed to locate makeable Electron application');
    }

    dir = resolvedDir;
    forgeConfig = await (0, _forgeConfig.default)(dir);
  });
  const actualOutDir = outDir || (0, _outDir.default)(dir, forgeConfig);
  const actualTargetPlatform = platform;
  platform = platform === 'mas' ? 'darwin' : platform;

  if (!['darwin', 'win32', 'linux', 'mas'].includes(actualTargetPlatform)) {
    throw new Error(`'${actualTargetPlatform}' is an invalid platform. Choices are 'darwin', 'mas', 'win32' or 'linux'`);
  }

  const makers = {};
  let targets = generateTargets(forgeConfig, overrideTargets);
  let targetId = 0;

  for (const target of targets) {
    let maker; // eslint-disable-next-line no-underscore-dangle

    if (target.__isElectronForgeMaker) {
      maker = target; // eslint-disable-next-line no-continue

      if (!maker.platforms.includes(actualTargetPlatform)) continue;
    } else {
      const resolvableTarget = target;
      const MakerClass = (0, _requireSearch.default)(dir, [resolvableTarget.name]);

      if (!MakerClass) {
        throw new Error(`Could not find module with name: ${resolvableTarget.name}. Make sure it's listed in the devDependencies of your package.json`);
      }

      maker = new MakerClass(resolvableTarget.config, resolvableTarget.platforms || undefined); // eslint-disable-next-line no-continue

      if (!maker.platforms.includes(actualTargetPlatform)) continue;
    }

    if (!maker.isSupportedOnCurrentPlatform) {
      throw new Error([`Maker for target ${maker.name} is incompatible with this version of `, 'electron-forge, please upgrade or contact the maintainer ', '(needs to implement \'isSupportedOnCurrentPlatform)\')'].join(''));
    }

    if (!(await maker.isSupportedOnCurrentPlatform())) {
      throw new Error([`Cannot make for ${platform} and target ${maker.name}: the maker declared `, `that it cannot run on ${process.platform}`].join(''));
    }

    maker.ensureExternalBinariesExist();
    makers[targetId] = maker;
    targetId += 1;
  }

  if (!skipPackage) {
    (0, _messages.info)(interactive, 'We need to package your application before we can make it'.green);
    await (0, _package.default)({
      dir,
      interactive,
      arch,
      outDir: actualOutDir,
      platform: actualTargetPlatform
    });
  } else {
    (0, _messages.warn)(interactive, 'WARNING: Skipping the packaging step, this could result in an out of date build'.red);
  }

  targets = targets.filter((_, i) => makers[i]);

  if (targets.length === 0) {
    throw new Error(`Could not find any make targets configured for the "${actualTargetPlatform}" platform.`);
  }

  (0, _messages.info)(interactive, `Making for the following targets: ${`${targets.map((t, i) => makers[i].name).join(', ')}`.cyan}`);
  const packageJSON = await (0, _readPackageJson.readMutatedPackageJson)(dir, forgeConfig);
  const appName = forgeConfig.packagerConfig.name || packageJSON.productName || packageJSON.name;
  const outputs = [];
  await (0, _hook.runHook)(forgeConfig, 'preMake');

  for (const targetArch of (0, _parseArchs.default)(platform, arch, await (0, _electronVersion.getElectronVersion)(dir, packageJSON))) {
    const packageDir = _path.default.resolve(actualOutDir, `${appName}-${actualTargetPlatform}-${targetArch}`);

    if (!(await _fsExtra.default.pathExists(packageDir))) {
      throw new Error(`Couldn't find packaged app at: ${packageDir}`);
    }

    targetId = 0; // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-unused-vars

    for (const _target of targets) {
      const maker = makers[targetId];
      targetId += 1; // eslint-disable-next-line no-loop-func

      await (0, _asyncOra.asyncOra)(`Making for target: ${maker.name.green} - On platform: ${actualTargetPlatform.cyan} - For arch: ${targetArch.cyan}`, async () => {
        try {
          /**
           * WARNING: DO NOT ATTEMPT TO PARALLELIZE MAKERS
           *
           * Currently it is assumed we have 1 maker per make call but that is
           * not enforced.  It is technically possible to have 1 maker be called
           * multiple times.  The "prepareConfig" method however implicitly
           * requires a lock that is not enforced.  There are two options:
           *
           *   * Provide makers a getConfig() method
           *   * Remove support for config being provided as a method
           *   * Change the entire API of maker from a single constructor to
           *     providing a MakerFactory
           */
          maker.prepareConfig(targetArch);
          const artifacts = await maker.make({
            appName,
            forgeConfig,
            packageJSON,
            targetArch,
            dir: packageDir,
            makeDir: _path.default.resolve(actualOutDir, 'make'),
            targetPlatform: actualTargetPlatform
          });
          outputs.push({
            artifacts,
            packageJSON,
            platform: actualTargetPlatform,
            arch: targetArch
          });
        } catch (err) {
          if (err) {
            // eslint-disable-next-line no-throw-literal
            throw {
              message: `An error occured while making for target: ${maker.name}`,
              stack: `${err.message}\n${err.stack}`
            };
          } else {
            throw new Error(`An unknown error occured while making for target: ${maker.name}`);
          }
        }
      });
    }
  } // If the postMake hooks modifies the locations / names of the outputs it must return
  // the new locations so that the publish step knows where to look


  return (0, _hook.runMutatingHook)(forgeConfig, 'postMake', outputs);
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWFrZS50cyJdLCJuYW1lcyI6WyJNYWtlckltcGwiLCJNYWtlckJhc2UiLCJnZW5lcmF0ZVRhcmdldHMiLCJmb3JnZUNvbmZpZyIsIm92ZXJyaWRlVGFyZ2V0cyIsIm1hcCIsInRhcmdldCIsIm1ha2VycyIsImZpbmQiLCJtYWtlciIsIm5hbWUiLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwiaW50ZXJhY3RpdmUiLCJza2lwUGFja2FnZSIsImFyY2giLCJwbGF0Zm9ybSIsIm91dERpciIsImFzeW5jT3JhIiwicmVzb2x2ZWREaXIiLCJFcnJvciIsImFjdHVhbE91dERpciIsImFjdHVhbFRhcmdldFBsYXRmb3JtIiwiaW5jbHVkZXMiLCJ0YXJnZXRzIiwidGFyZ2V0SWQiLCJfX2lzRWxlY3Ryb25Gb3JnZU1ha2VyIiwicGxhdGZvcm1zIiwicmVzb2x2YWJsZVRhcmdldCIsIk1ha2VyQ2xhc3MiLCJjb25maWciLCJ1bmRlZmluZWQiLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwiam9pbiIsImVuc3VyZUV4dGVybmFsQmluYXJpZXNFeGlzdCIsImdyZWVuIiwicmVkIiwiZmlsdGVyIiwiXyIsImkiLCJsZW5ndGgiLCJ0IiwiY3lhbiIsInBhY2thZ2VKU09OIiwiYXBwTmFtZSIsInBhY2thZ2VyQ29uZmlnIiwicHJvZHVjdE5hbWUiLCJvdXRwdXRzIiwidGFyZ2V0QXJjaCIsInBhY2thZ2VEaXIiLCJwYXRoIiwicmVzb2x2ZSIsImZzIiwicGF0aEV4aXN0cyIsIl90YXJnZXQiLCJwcmVwYXJlQ29uZmlnIiwiYXJ0aWZhY3RzIiwibWFrZSIsIm1ha2VEaXIiLCJ0YXJnZXRQbGF0Zm9ybSIsInB1c2giLCJlcnIiLCJtZXNzYWdlIiwic3RhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUlBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNB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SUFBSSxFQUFFaUM7QUFKSyxXQUFiO0FBTUQsU0EvQkQsQ0ErQkUsT0FBT2EsR0FBUCxFQUFZO0FBQ1osY0FBSUEsR0FBSixFQUFTO0FBQ1A7QUFDQSxrQkFBTTtBQUNKQyxjQUFBQSxPQUFPLEVBQUcsNkNBQTRDdEQsS0FBSyxDQUFDQyxJQUFLLEVBRDdEO0FBRUpzRCxjQUFBQSxLQUFLLEVBQUcsR0FBRUYsR0FBRyxDQUFDQyxPQUFRLEtBQUlELEdBQUcsQ0FBQ0UsS0FBTTtBQUZoQyxhQUFOO0FBSUQsV0FORCxNQU1PO0FBQ0wsa0JBQU0sSUFBSTNDLEtBQUosQ0FBVyxxREFBb0RaLEtBQUssQ0FBQ0MsSUFBSyxFQUExRSxDQUFOO0FBQ0Q7QUFDRjtBQUNGLE9BM0NLLENBQU47QUE0Q0Q7QUFDRixHQTFKZ0IsQ0E0SmpCO0FBQ0E7OztBQUNBLFNBQU8sMkJBQWdCUCxXQUFoQixFQUE2QixVQUE3QixFQUF5QzZDLE9BQXpDLENBQVA7QUFDRCxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjb2xvcnMnO1xuaW1wb3J0IHsgYXN5bmNPcmEgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvYXN5bmMtb3JhJztcbmltcG9ydCB7IGdldEhvc3RBcmNoIH0gZnJvbSAnQGVsZWN0cm9uL2dldCc7XG5pbXBvcnQge1xuICBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIsIEZvcmdlQ29uZmlnLCBGb3JnZUFyY2gsIEZvcmdlUGxhdGZvcm0sIEZvcmdlTWFrZVJlc3VsdCxcbn0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgTWFrZXJCYXNlIGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9tYWtlci1iYXNlJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IGdldEZvcmdlQ29uZmlnIGZyb20gJy4uL3V0aWwvZm9yZ2UtY29uZmlnJztcbmltcG9ydCB7IHJ1bkhvb2ssIHJ1bk11dGF0aW5nSG9vayB9IGZyb20gJy4uL3V0aWwvaG9vayc7XG5pbXBvcnQgeyBpbmZvLCB3YXJuIH0gZnJvbSAnLi4vdXRpbC9tZXNzYWdlcyc7XG5pbXBvcnQgcGFyc2VBcmNocyBmcm9tICcuLi91dGlsL3BhcnNlLWFyY2hzJztcbmltcG9ydCB7IHJlYWRNdXRhdGVkUGFja2FnZUpzb24gfSBmcm9tICcuLi91dGlsL3JlYWQtcGFja2FnZS1qc29uJztcbmltcG9ydCByZXNvbHZlRGlyIGZyb20gJy4uL3V0aWwvcmVzb2x2ZS1kaXInO1xuaW1wb3J0IGdldEN1cnJlbnRPdXREaXIgZnJvbSAnLi4vdXRpbC9vdXQtZGlyJztcbmltcG9ydCB7IGdldEVsZWN0cm9uVmVyc2lvbiB9IGZyb20gJy4uL3V0aWwvZWxlY3Ryb24tdmVyc2lvbic7XG5pbXBvcnQgcmVxdWlyZVNlYXJjaCBmcm9tICcuLi91dGlsL3JlcXVpcmUtc2VhcmNoJztcblxuaW1wb3J0IHBhY2thZ2VyIGZyb20gJy4vcGFja2FnZSc7XG5cbmNsYXNzIE1ha2VySW1wbCBleHRlbmRzIE1ha2VyQmFzZTxhbnk+IHtcbiAgbmFtZSA9ICdpbXBsJztcblxuICBkZWZhdWx0UGxhdGZvcm1zID0gW107XG59XG5cbnR5cGUgTWFrZVRhcmdldCA9IElGb3JnZVJlc29sdmFibGVNYWtlciB8IE1ha2VyQmFzZTxhbnk+IHwgc3RyaW5nO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRhcmdldHMoZm9yZ2VDb25maWc6IEZvcmdlQ29uZmlnLCBvdmVycmlkZVRhcmdldHM/OiBNYWtlVGFyZ2V0W10pIHtcbiAgaWYgKG92ZXJyaWRlVGFyZ2V0cykge1xuICAgIHJldHVybiBvdmVycmlkZVRhcmdldHMubWFwKCh0YXJnZXQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZm9yZ2VDb25maWcubWFrZXJzLmZpbmQoXG4gICAgICAgICAgKG1ha2VyKSA9PiAobWFrZXIgYXMgSUZvcmdlUmVzb2x2YWJsZU1ha2VyKS5uYW1lID09PSB0YXJnZXQsXG4gICAgICAgICkgfHwgeyBuYW1lOiB0YXJnZXQgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZm9yZ2VDb25maWcubWFrZXJzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1ha2VPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBhcHAgZnJvbSB3aGljaCBkaXN0cnVidXRhYmxlcyBhcmUgZ2VuZXJhdGVkXG4gICAqL1xuICBkaXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBzZW5zaWJsZSBkZWZhdWx0cyBvciBwcm9tcHQgdGhlIHVzZXIgdmlzdWFsbHlcbiAgICovXG4gIGludGVyYWN0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2tpcCB0aGUgcHJlLW1ha2UgcGFja2FnaW5nIHN0ZXBcbiAgICovXG4gIHNraXBQYWNrYWdlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIG1ha2UgdGFyZ2V0cyB0byBvdmVycmlkZSB5b3VyIGZvcmdlIGNvbmZpZ1xuICAgKi9cbiAgb3ZlcnJpZGVUYXJnZXRzPzogTWFrZVRhcmdldFtdO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBhcmNoaXRlY3R1cmVcbiAgICovXG4gIGFyY2g/OiBGb3JnZUFyY2g7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IHBsYXRmb3JtXG4gICAqL1xuICBwbGF0Zm9ybT86IEZvcmdlUGxhdGZvcm07XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgZ2VuZXJhdGVkIGRpc3RyaWJ1dGFibGVzXG4gICAqL1xuICBvdXREaXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jICh7XG4gIGRpciA9IHByb2Nlc3MuY3dkKCksXG4gIGludGVyYWN0aXZlID0gZmFsc2UsXG4gIHNraXBQYWNrYWdlID0gZmFsc2UsXG4gIGFyY2ggPSBnZXRIb3N0QXJjaCgpIGFzIEZvcmdlQXJjaCxcbiAgcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtIGFzIEZvcmdlUGxhdGZvcm0sXG4gIG92ZXJyaWRlVGFyZ2V0cyxcbiAgb3V0RGlyLFxufTogTWFrZU9wdGlvbnMpID0+IHtcbiAgYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcblxuICBsZXQgZm9yZ2VDb25maWchOiBGb3JnZUNvbmZpZztcbiAgYXdhaXQgYXN5bmNPcmEoJ1Jlc29sdmluZyBGb3JnZSBDb25maWcnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWREaXIgPSBhd2FpdCByZXNvbHZlRGlyKGRpcik7XG4gICAgaWYgKCFyZXNvbHZlZERpcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9jYXRlIG1ha2VhYmxlIEVsZWN0cm9uIGFwcGxpY2F0aW9uJyk7XG4gICAgfVxuICAgIGRpciA9IHJlc29sdmVkRGlyO1xuXG4gICAgZm9yZ2VDb25maWcgPSBhd2FpdCBnZXRGb3JnZUNvbmZpZyhkaXIpO1xuICB9KTtcblxuICBjb25zdCBhY3R1YWxPdXREaXIgPSBvdXREaXIgfHwgZ2V0Q3VycmVudE91dERpcihkaXIsIGZvcmdlQ29uZmlnKTtcblxuICBjb25zdCBhY3R1YWxUYXJnZXRQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICBwbGF0Zm9ybSA9IHBsYXRmb3JtID09PSAnbWFzJyA/ICdkYXJ3aW4nIDogcGxhdGZvcm07XG4gIGlmICghWydkYXJ3aW4nLCAnd2luMzInLCAnbGludXgnLCAnbWFzJ10uaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHthY3R1YWxUYXJnZXRQbGF0Zm9ybX0nIGlzIGFuIGludmFsaWQgcGxhdGZvcm0uIENob2ljZXMgYXJlICdkYXJ3aW4nLCAnbWFzJywgJ3dpbjMyJyBvciAnbGludXgnYCk7XG4gIH1cblxuICBjb25zdCBtYWtlcnM6IHtcbiAgICBba2V5OiBudW1iZXJdOiBNYWtlckJhc2U8YW55PjtcbiAgfSA9IHt9O1xuXG4gIGxldCB0YXJnZXRzID0gZ2VuZXJhdGVUYXJnZXRzKGZvcmdlQ29uZmlnLCBvdmVycmlkZVRhcmdldHMpO1xuXG4gIGxldCB0YXJnZXRJZCA9IDA7XG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBsZXQgbWFrZXI6IE1ha2VyQmFzZTxhbnk+O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIGlmICgodGFyZ2V0IGFzIE1ha2VyQmFzZTxhbnk+KS5fX2lzRWxlY3Ryb25Gb3JnZU1ha2VyKSB7XG4gICAgICBtYWtlciA9IHRhcmdldCBhcyBNYWtlckJhc2U8YW55PjtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgaWYgKCFtYWtlci5wbGF0Zm9ybXMuaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzb2x2YWJsZVRhcmdldDogSUZvcmdlUmVzb2x2YWJsZU1ha2VyID0gdGFyZ2V0IGFzIElGb3JnZVJlc29sdmFibGVNYWtlcjtcbiAgICAgIGNvbnN0IE1ha2VyQ2xhc3MgPSByZXF1aXJlU2VhcmNoPHR5cGVvZiBNYWtlckltcGw+KGRpciwgW3Jlc29sdmFibGVUYXJnZXQubmFtZV0pO1xuICAgICAgaWYgKCFNYWtlckNsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgbW9kdWxlIHdpdGggbmFtZTogJHtyZXNvbHZhYmxlVGFyZ2V0Lm5hbWV9LiBNYWtlIHN1cmUgaXQncyBsaXN0ZWQgaW4gdGhlIGRldkRlcGVuZGVuY2llcyBvZiB5b3VyIHBhY2thZ2UuanNvbmApO1xuICAgICAgfVxuXG4gICAgICBtYWtlciA9IG5ldyBNYWtlckNsYXNzKHJlc29sdmFibGVUYXJnZXQuY29uZmlnLCByZXNvbHZhYmxlVGFyZ2V0LnBsYXRmb3JtcyB8fCB1bmRlZmluZWQpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBpZiAoIW1ha2VyLnBsYXRmb3Jtcy5pbmNsdWRlcyhhY3R1YWxUYXJnZXRQbGF0Zm9ybSkpIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghbWFrZXIuaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgYE1ha2VyIGZvciB0YXJnZXQgJHttYWtlci5uYW1lfSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGlzIHZlcnNpb24gb2YgYCxcbiAgICAgICAgJ2VsZWN0cm9uLWZvcmdlLCBwbGVhc2UgdXBncmFkZSBvciBjb250YWN0IHRoZSBtYWludGFpbmVyICcsXG4gICAgICAgICcobmVlZHMgdG8gaW1wbGVtZW50IFxcJ2lzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pXFwnKScsXG4gICAgICBdLmpvaW4oJycpKTtcbiAgICB9XG5cbiAgICBpZiAoIWF3YWl0IG1ha2VyLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgYENhbm5vdCBtYWtlIGZvciAke3BsYXRmb3JtfSBhbmQgdGFyZ2V0ICR7bWFrZXIubmFtZX06IHRoZSBtYWtlciBkZWNsYXJlZCBgLFxuICAgICAgICBgdGhhdCBpdCBjYW5ub3QgcnVuIG9uICR7cHJvY2Vzcy5wbGF0Zm9ybX1gLFxuICAgICAgXS5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgbWFrZXIuZW5zdXJlRXh0ZXJuYWxCaW5hcmllc0V4aXN0KCk7XG5cbiAgICBtYWtlcnNbdGFyZ2V0SWRdID0gbWFrZXI7XG4gICAgdGFyZ2V0SWQgKz0gMTtcbiAgfVxuXG4gIGlmICghc2tpcFBhY2thZ2UpIHtcbiAgICBpbmZvKGludGVyYWN0aXZlLCAnV2UgbmVlZCB0byBwYWNrYWdlIHlvdXIgYXBwbGljYXRpb24gYmVmb3JlIHdlIGNhbiBtYWtlIGl0Jy5ncmVlbik7XG4gICAgYXdhaXQgcGFja2FnZXIoe1xuICAgICAgZGlyLFxuICAgICAgaW50ZXJhY3RpdmUsXG4gICAgICBhcmNoLFxuICAgICAgb3V0RGlyOiBhY3R1YWxPdXREaXIsXG4gICAgICBwbGF0Zm9ybTogYWN0dWFsVGFyZ2V0UGxhdGZvcm0sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybihpbnRlcmFjdGl2ZSwgJ1dBUk5JTkc6IFNraXBwaW5nIHRoZSBwYWNrYWdpbmcgc3RlcCwgdGhpcyBjb3VsZCByZXN1bHQgaW4gYW4gb3V0IG9mIGRhdGUgYnVpbGQnLnJlZCk7XG4gIH1cblxuICB0YXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIoKF8sIGkpID0+IG1ha2Vyc1tpXSk7XG5cbiAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhbnkgbWFrZSB0YXJnZXRzIGNvbmZpZ3VyZWQgZm9yIHRoZSBcIiR7YWN0dWFsVGFyZ2V0UGxhdGZvcm19XCIgcGxhdGZvcm0uYCk7XG4gIH1cblxuICBpbmZvKGludGVyYWN0aXZlLCBgTWFraW5nIGZvciB0aGUgZm9sbG93aW5nIHRhcmdldHM6ICR7YCR7dGFyZ2V0cy5tYXAoKHQsIGkpID0+IG1ha2Vyc1tpXS5uYW1lKS5qb2luKCcsICcpfWAuY3lhbn1gKTtcblxuICBjb25zdCBwYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRNdXRhdGVkUGFja2FnZUpzb24oZGlyLCBmb3JnZUNvbmZpZyk7XG4gIGNvbnN0IGFwcE5hbWUgPSBmb3JnZUNvbmZpZy5wYWNrYWdlckNvbmZpZy5uYW1lIHx8IHBhY2thZ2VKU09OLnByb2R1Y3ROYW1lIHx8IHBhY2thZ2VKU09OLm5hbWU7XG4gIGNvbnN0IG91dHB1dHM6IEZvcmdlTWFrZVJlc3VsdFtdID0gW107XG5cbiAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3ByZU1ha2UnKTtcblxuICBmb3IgKGNvbnN0IHRhcmdldEFyY2ggb2YgcGFyc2VBcmNocyhwbGF0Zm9ybSwgYXJjaCwgYXdhaXQgZ2V0RWxlY3Ryb25WZXJzaW9uKGRpciwgcGFja2FnZUpTT04pKSkge1xuICAgIGNvbnN0IHBhY2thZ2VEaXIgPSBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCBgJHthcHBOYW1lfS0ke2FjdHVhbFRhcmdldFBsYXRmb3JtfS0ke3RhcmdldEFyY2h9YCk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhwYWNrYWdlRGlyKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBwYWNrYWdlZCBhcHAgYXQ6ICR7cGFja2FnZURpcn1gKTtcbiAgICB9XG5cbiAgICB0YXJnZXRJZCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IF90YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgY29uc3QgbWFrZXIgPSBtYWtlcnNbdGFyZ2V0SWRdO1xuICAgICAgdGFyZ2V0SWQgKz0gMTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgYXdhaXQgYXN5bmNPcmEoYE1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWUuZ3JlZW59IC0gT24gcGxhdGZvcm06ICR7YWN0dWFsVGFyZ2V0UGxhdGZvcm0uY3lhbn0gLSBGb3IgYXJjaDogJHt0YXJnZXRBcmNoLmN5YW59YCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdBUk5JTkc6IERPIE5PVCBBVFRFTVBUIFRPIFBBUkFMTEVMSVpFIE1BS0VSU1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQ3VycmVudGx5IGl0IGlzIGFzc3VtZWQgd2UgaGF2ZSAxIG1ha2VyIHBlciBtYWtlIGNhbGwgYnV0IHRoYXQgaXNcbiAgICAgICAgICAgKiBub3QgZW5mb3JjZWQuICBJdCBpcyB0ZWNobmljYWxseSBwb3NzaWJsZSB0byBoYXZlIDEgbWFrZXIgYmUgY2FsbGVkXG4gICAgICAgICAgICogbXVsdGlwbGUgdGltZXMuICBUaGUgXCJwcmVwYXJlQ29uZmlnXCIgbWV0aG9kIGhvd2V2ZXIgaW1wbGljaXRseVxuICAgICAgICAgICAqIHJlcXVpcmVzIGEgbG9jayB0aGF0IGlzIG5vdCBlbmZvcmNlZC4gIFRoZXJlIGFyZSB0d28gb3B0aW9uczpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgKiBQcm92aWRlIG1ha2VycyBhIGdldENvbmZpZygpIG1ldGhvZFxuICAgICAgICAgICAqICAgKiBSZW1vdmUgc3VwcG9ydCBmb3IgY29uZmlnIGJlaW5nIHByb3ZpZGVkIGFzIGEgbWV0aG9kXG4gICAgICAgICAgICogICAqIENoYW5nZSB0aGUgZW50aXJlIEFQSSBvZiBtYWtlciBmcm9tIGEgc2luZ2xlIGNvbnN0cnVjdG9yIHRvXG4gICAgICAgICAgICogICAgIHByb3ZpZGluZyBhIE1ha2VyRmFjdG9yeVxuICAgICAgICAgICAqL1xuICAgICAgICAgIG1ha2VyLnByZXBhcmVDb25maWcodGFyZ2V0QXJjaCk7XG4gICAgICAgICAgY29uc3QgYXJ0aWZhY3RzID0gYXdhaXQgbWFrZXIubWFrZSh7XG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgZm9yZ2VDb25maWcsXG4gICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICAgIHRhcmdldEFyY2gsXG4gICAgICAgICAgICBkaXI6IHBhY2thZ2VEaXIsXG4gICAgICAgICAgICBtYWtlRGlyOiBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCAnbWFrZScpLFxuICAgICAgICAgICAgdGFyZ2V0UGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFydGlmYWN0cyxcbiAgICAgICAgICAgIHBhY2thZ2VKU09OLFxuICAgICAgICAgICAgcGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgICAgICAgICAgYXJjaDogdGFyZ2V0QXJjaCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYEFuIGVycm9yIG9jY3VyZWQgd2hpbGUgbWFraW5nIGZvciB0YXJnZXQ6ICR7bWFrZXIubmFtZX1gLFxuICAgICAgICAgICAgICBzdGFjazogYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gdW5rbm93biBlcnJvciBvY2N1cmVkIHdoaWxlIG1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgcG9zdE1ha2UgaG9va3MgbW9kaWZpZXMgdGhlIGxvY2F0aW9ucyAvIG5hbWVzIG9mIHRoZSBvdXRwdXRzIGl0IG11c3QgcmV0dXJuXG4gIC8vIHRoZSBuZXcgbG9jYXRpb25zIHNvIHRoYXQgdGhlIHB1Ymxpc2ggc3RlcCBrbm93cyB3aGVyZSB0byBsb29rXG4gIHJldHVybiBydW5NdXRhdGluZ0hvb2soZm9yZ2VDb25maWcsICdwb3N0TWFrZScsIG91dHB1dHMpO1xufTtcbiJdfQ==